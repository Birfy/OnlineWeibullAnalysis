<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Weibull Analysis</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.3.0/math.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jstat@latest/dist/jstat.min.js"></script>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    #plot {
      width: 800px;
      height: 600px;
    }
    .axis-label {
      font-size: 12px;
      text-anchor: middle;
    }
    .grid line {
      stroke: lightgrey;
      stroke-opacity: 0.7;
      shape-rendering: crispEdges;
    }
    .grid path {
      stroke-width: 0;
    }
    .line {
      fill: none;
      stroke-width: 2px;
    }
    .dot {
      stroke: #fff;
      stroke-width: 1.5px;
    }
    .legend {
      font-size: 12px;
    }
    .tick text {
      font-size: 10px;
    }
  </style>
</head>
<body>
  <h1>Weibull 分析</h1>

  <label for="df">输入失效时间（逗号分隔）:</label><br>
  <textarea id="df" rows="2" cols="50" placeholder="例如：16,34,53,75,93,120"></textarea><br><br>

  <label for="ds">输入未失效测试时间（右删失，可留空）:</label><br>
  <textarea id="ds" rows="2" cols="50" placeholder="例如：50,100,200,1000（可选）"></textarea><br><br>

  <button onclick="runAnalysis()">开始分析</button>

  <div id="plot"></div>

  <script>
    class Weibull {
      constructor(df, ds, cl = 0.95) {
        this.df = df;
        this.df.sort((a, b) => a - b);
        this.ds = ds || []; // 若为空，设为空数组
        this.ds.sort((a, b) => a - b);
        this.cl = cl;
        this.beta = 1;
        this.eta = 1;
      }

      h(beta_) {
        const dat = this.df.concat(this.ds);
        const a = this.df.reduce((acc, v) => acc + Math.log(v), 0);
        const b = dat.reduce((acc, v) => acc + Math.pow(v, beta_) * Math.log(v), 0);
        const c = dat.reduce((acc, v) => acc + Math.pow(v, beta_), 0);
        return (1 / beta_) + a / this.df.length - b / c;
      }

      mle() {
        const tol = 1e-5;
        let beta = 0.1, diff, iter = 0;
        const maxIter = 1000;

        do {
          const f = this.h(beta);
          const df = (this.h(beta + 1e-7) - this.h(beta - 1e-7)) / 2e-7;
          const newBeta = beta - f / df;
          diff = Math.abs(newBeta - beta);
          beta = newBeta;
          iter++;
        } while (diff > tol && iter < maxIter);

        this.beta = beta;

        const dat = this.df.concat(this.ds);
        const sumPow = dat.reduce((acc, v) => acc + Math.pow(v, beta), 0);
        this.eta = Math.pow(sumPow / this.df.length, 1 / beta);
      }

      cdf(x) {
        return 1 - Math.exp(-Math.pow(x / this.eta, this.beta));
      }

      generateCDFCurve(min, max) {
        const x = [], y = [];
        for (let i = min; i <= max; i += (max - min) / 500) {
          x.push(i);
          y.push(this.cdf(i));
        }
        return { x, y };
      }
    }

    function medianRanks(df, ds, cl = 0.5) {
        const all = df.concat(ds);
        const n = all.length;
        
        // Sort the failure times and assign ranks
        const sortedFailures = [...df].sort((a, b) => a - b);
        
        // Calculate ranks, handling ties properly
        const ranks = [];
        let currentRank = 1;
        
        while (currentRank <= sortedFailures.length) {
            const currentValue = sortedFailures[currentRank - 1];
            
            // Count how many failures have this same value
            let tieCount = 1;
            while (currentRank - 1 + tieCount < sortedFailures.length && 
                sortedFailures[currentRank - 1 + tieCount] === currentValue) {
            tieCount++;
            }
            
            // Calculate average rank for these tied values
            const averageRank = currentRank + (tieCount - 1) / 2;
            
            // Assign the average rank to all tied values
            for (let i = 0; i < tieCount; i++) {
            ranks.push(averageRank);
            }
            
            currentRank += tieCount;
        }
  
        // Calculate median ranks using Bernard's approximation
        const bernardRanks = ranks.map(r => (r - 0.3) / (n + 0.4));
        
        // Or using exact median ranks (beta distribution)
        const exactMedianRanks = ranks.map(r => jStat.beta.inv(cl, r, n - r + 1));
        
        // For Weibull analysis, Bernard's approximation is often sufficient
        // return bernardRanks;
        
        // Or if you prefer the exact method:
        return exactMedianRanks;
    }

    function fisherBounds(w, rel) {
      const { beta: b, eta, df, ds } = w;
      const sum1 = df.reduce((acc, x) => acc + (-1 / b ** 2 - Math.pow(x / eta, b) * Math.log(x / eta) ** 2), 0) +
                  ds.reduce((acc, x) => acc - Math.pow(x / eta, b) * Math.log(x / eta) ** 2, 0);
      const sum2 = df.reduce((acc, x) => acc + (b / eta ** 2 - Math.pow(x / eta, b) * b * (b + 1) / eta ** 2), 0) +
                  ds.reduce((acc, x) => acc - Math.pow(x / eta, b) * b * (b + 1) / eta ** 2, 0);
      const sum3 = df.reduce((acc, x) => acc + (-1 / eta + Math.pow(x / eta, b) * (b * Math.log(x / eta) + 1) / eta), 0) +
                  ds.reduce((acc, x) => acc + Math.pow(x / eta, b) * (b * Math.log(x / eta) + 1) / eta, 0);

      const fisher = math.matrix([[-sum1, -sum3], [-sum3, -sum2]]);
      const f_inv = math.inv(fisher);
      const z = jStat.normal.inv((1 + w.cl) / 2, 0, 1);

      const lower = [], upper = [];

      for (let x of rel) {
        const ln_ln = Math.log(-Math.log(1 - x));
        const var_y = f_inv.get([1,1]) / eta ** 2 +
                      (ln_ln ** 2) * f_inv.get([0,0]) / b ** 4 -
                      2 * ln_ln * f_inv.get([0,1]) / (b ** 2 * eta);

        const y = Math.log(eta) + ln_ln / b;
        const delta = z * Math.sqrt(var_y);
        lower.push(Math.exp(y - delta));
        upper.push(Math.exp(y + delta));
      }

      return { lower, upper };
    }

    // Custom Weibull probability scale function
    function weibullScale(p) {
      return Math.log(-Math.log(1 - p));
    }

    // Inverse function for the Weibull probability scale
    function inverseWeibullScale(y) {
      return 1 - Math.exp(-Math.exp(y));
    }

    function createWeibullPlot(containerId, data, title) {
      // Clear previous plot
      d3.select(`#${containerId}`).html("");
      
      // Set up dimensions and margins
      const margin = {top: 50, right: 100, bottom: 60, left: 60};
      const width = 800 - margin.left - margin.right;
      const height = 600 - margin.top - margin.bottom;

      // Create SVG
      const svg = d3.select(`#${containerId}`)
        .append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
        .append("g")
        .attr("transform", `translate(${margin.left},${margin.top})`);

      // Add title
      svg.append("text")
        .attr("x", width / 2)
        .attr("y", -20)
        .attr("text-anchor", "middle")
        .style("font-size", "16px")
        .text(title);

      // Create scales
      const xScale = d3.scaleLog()
        .domain([d3.min(data.cdf.x), d3.max(data.cdf.x)])
        .range([0, width]);

      // Custom y-scale using Weibull probability scale
      const yScale = d3.scaleLinear()
        .domain([weibullScale(0.01), weibullScale(0.99)]) // 1% to 99%
        .range([height, 0]);

      // Create axes
      const xAxis = d3.axisBottom(xScale).ticks(10, ".1s");
      
      // Custom y-axis with Weibull probability scale ticks
      const yAxis = d3.axisLeft(yScale)
        .tickValues([weibullScale(0.01), weibullScale(0.05), weibullScale(0.1), 
                    weibullScale(0.2), weibullScale(0.3), weibullScale(0.4),
                    weibullScale(0.5), weibullScale(0.6), weibullScale(0.7),
                    weibullScale(0.8), weibullScale(0.9), weibullScale(0.95),
                    weibullScale(0.99)])
        .tickFormat(d => {
          // Convert back to probability for display
          const p = inverseWeibullScale(d);
          return `${(p * 100).toFixed(p >= 0.1 ? 0 : 1)}%`;
        });

      // Add X axis
      svg.append("g")
        .attr("transform", `translate(0,${height})`)
        .call(xAxis);

      // Add Y axis
      svg.append("g")
        .call(yAxis);

      // Add grid lines
      svg.append("g")
        .attr("class", "grid")
        .call(d3.axisLeft(yScale)
          .tickValues([weibullScale(0.1), weibullScale(0.2), weibullScale(0.3),
                      weibullScale(0.4), weibullScale(0.5), weibullScale(0.6),
                      weibullScale(0.7), weibullScale(0.8), weibullScale(0.9)])
          .tickSize(-width)
          .tickFormat(""));

      svg.append("g")
        .attr("class", "grid")
        .attr("transform", `translate(0,${height})`)
        .call(d3.axisBottom(xScale)
          .tickSize(-height)
          .tickFormat(""));

      // Add axis labels
      svg.append("text")
        .attr("class", "axis-label")
        .attr("x", width / 2)
        .attr("y", height + margin.bottom / 2)
        .text("时间");

      svg.append("text")
        .attr("class", "axis-label")
        .attr("transform", "rotate(-90)")
        .attr("x", -height / 2)
        .attr("y", -margin.left / 2)
        .text("累积失效概率");

      // Create line generators
      const cdfLine = d3.line()
        .x(d => xScale(d.x))
        .y(d => yScale(weibullScale(d.y)))
        .curve(d3.curveBasis);

      const lowerLine = d3.line()
        .x(d => xScale(d.x))
        .y(d => yScale(weibullScale(d.y)))
        .curve(d3.curveBasis);

      const upperLine = d3.line()
        .x(d => xScale(d.x))
        .y(d => yScale(weibullScale(d.y)))
        .curve(d3.curveBasis);

      // Prepare data for lines
      const cdfData = data.cdf.x.map((x, i) => ({x, y: data.cdf.y[i]}));
      const lowerData = data.bounds.lower.map((x, i) => ({x, y: data.rel[i]}));
      const upperData = data.bounds.upper.map((x, i) => ({x, y: data.rel[i]}));

      // Add CDF line
      svg.append("path")
        .datum(cdfData)
        .attr("class", "line")
        .attr("d", cdfLine)
        .attr("stroke", "steelblue")
        .attr("stroke-width", 2)
        .attr("fill", "none");

      // Add lower bound line
      svg.append("path")
        .datum(lowerData)
        .attr("class", "line")
        .attr("d", lowerLine)
        .attr("stroke", "red")
        .attr("stroke-width", 1.5)
        .attr("stroke-dasharray", "3,3")
        .attr("fill", "none");

      // Add upper bound line
      svg.append("path")
        .datum(upperData)
        .attr("class", "line")
        .attr("d", upperLine)
        .attr("stroke", "red")
        .attr("stroke-width", 1.5)
        .attr("stroke-dasharray", "3,3")
        .attr("fill", "none");

    
      // Add median ranks points
      svg.selectAll(".median-rank")
        .data(data.df.map((x, i) => ({x, y: data.mr[i]})))
        .enter()
        .append("circle")
        .attr("class", "dot")
        .attr("cx", d => xScale(d.x))
        .attr("cy", d => yScale(weibullScale(d.y)))
        .attr("r", 5)
        .attr("fill", "orange");

      // Add legend
      const legend = svg.append("g")
        .attr("class", "legend")
        .attr("transform", `translate(${width - 100}, 20)`);

      legend.append("rect")
        .attr("x", 0)
        .attr("y", 0)
        .attr("width", 12)
        .attr("height", 12)
        .attr("fill", "steelblue");

      legend.append("text")
        .attr("x", 20)
        .attr("y", 10)
        .text("Weibull CDF");

      legend.append("rect")
        .attr("x", 0)
        .attr("y", 20)
        .attr("width", 12)
        .attr("height", 12)
        .attr("fill", "orange");

      legend.append("text")
        .attr("x", 20)
        .attr("y", 30)
        .text("Median Ranks");

      legend.append("path")
        .attr("d", "M0,40 L12,40")
        .attr("stroke", "red")
        .attr("stroke-width", 1.5)
        .attr("stroke-dasharray", "3,3");

      legend.append("text")
        .attr("x", 20)
        .attr("y", 45)
        .text("Confidence Bounds");
    }

    function runAnalysis() {
      const dfInput = document.getElementById('df').value;
      const dsInput = document.getElementById('ds').value;

      const df = dfInput.split(',').map(Number).filter(v => !isNaN(v));
      const ds = dsInput.trim() === '' ? [] : dsInput.split(',').map(Number).filter(v => !isNaN(v));

      if (df.length < 2) {
        alert("请输入至少两个失效时间（df）！");
        return;
      }

      const w = new Weibull(df, ds);
      w.mle();

      const dataX = df.concat(ds);
      const minX = Math.min(...dataX) * 0.1;
      const maxX = Math.max(...dataX) * 10;

      const cdf = w.generateCDFCurve(minX, maxX);
      const mr = medianRanks(df, ds);
      const rel = Array.from({length: 98}, (_, i) => (i + 1) / 100);
      const bounds = fisherBounds(w, rel);

      const plotData = {
        cdf,
        df,
        mr,
        rel,
        bounds
      };

      const title = `Weibull 分析图 - 形状(β): ${w.beta.toFixed(4)}，尺度(η): ${w.eta.toFixed(4)}`;
      createWeibullPlot('plot', plotData, title);
    }
  </script>
</body>
</html>
