<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Weibull Analysis</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.3.0/math.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jstat@latest/dist/jstat.min.js"></script>
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
</head>
<body>
  <h1>Weibull 分析</h1>

  <label for="df">输入失效时间 df（逗号分隔）:</label><br>
  <textarea id="df" rows="2" cols="50" placeholder="例如：16,34,53,75,93,120"></textarea><br><br>

  <label for="ds">输入暂停时间 ds（可留空）:</label><br>
  <textarea id="ds" rows="2" cols="50" placeholder="例如：50,100,200,1000（可选）"></textarea><br><br>

  <button onclick="runAnalysis()">开始分析</button>

  <div id="plot"></div>

  <script>
    class Weibull {
      constructor(df, ds, cl = 0.95) {
        this.df = df;
        this.ds = ds || []; // 若为空，设为空数组
        this.cl = cl;
        this.beta = 1;
        this.eta = 1;
      }

      h(beta_) {
        const dat = this.df.concat(this.ds);
        const a = this.df.reduce((acc, v) => acc + Math.log(v), 0);
        const b = dat.reduce((acc, v) => acc + Math.pow(v, beta_) * Math.log(v), 0);
        const c = dat.reduce((acc, v) => acc + Math.pow(v, beta_), 0);
        return (1 / beta_) + a / this.df.length - b / c;
      }

      mle() {
        const tol = 1e-5;
        let beta = 1.0, diff, iter = 0;
        const maxIter = 1000;

        do {
          const f = this.h(beta);
          const df = (this.h(beta + 1e-6) - f) / 1e-6;
          const newBeta = beta - f / df;
          diff = Math.abs(newBeta - beta);
          beta = newBeta;
          iter++;
        } while (diff > tol && iter < maxIter);

        this.beta = beta;

        const dat = this.df.concat(this.ds);
        const sumPow = dat.reduce((acc, v) => acc + Math.pow(v, beta), 0);
        this.eta = Math.pow(sumPow / this.df.length, 1 / beta);
      }

      cdf(x) {
        return 1 - Math.exp(-Math.pow(x / this.eta, this.beta));
      }

      generateCDFCurve(min, max) {
        const x = [], y = [];
        for (let i = min; i <= max; i += (max - min) / 500) {
          x.push(i);
          y.push(this.cdf(i));
        }
        return { x, y };
      }
    }

    function medianRanks(df, ds, cl = 0.5) {
      const all = df.concat(ds);
      const n = all.length;
      const countDict = {};
      df.forEach((v) => countDict[v] = (countDict[v] || 0) + 1);

      const revRank = [];
      const sortedAll = [...all].sort((a, b) => a - b);
      const countLessThan = (v) => sortedAll.filter(x => x < v).length;
      let seen = new Set();

      for (let j of df) {
        if (countDict[j] > 1) {
          if (seen.has(j)) continue;
          seen.add(j);
          for (let i = 0; i < countDict[j]; i++) {
            const count = countLessThan(j) + i;
            revRank.push(n - count);
          }
        } else {
          revRank.push(n - countLessThan(j));
        }
      }

      const adjRanks = [];
      let prev = 0;
      for (let i = 0; i < df.length; i++) {
        const adj = (revRank[i] * prev + n + 1) / (revRank[i] + 1);
        adjRanks.push(adj);
        prev = adj;
      }

      return adjRanks.map(r => jStat.beta.inv(cl, r, n - r + 1));
    }

    function fisherBounds(w, rel) {
      const { beta: b, eta, df, ds } = w;
      const sum1 = df.reduce((acc, x) => acc + (-1 / b ** 2 - Math.pow(x / eta, b) * Math.log(x / eta) ** 2), 0) +
                  ds.reduce((acc, x) => acc - Math.pow(x / eta, b) * Math.log(x / eta) ** 2, 0);
      const sum2 = df.reduce((acc, x) => acc + (b / eta ** 2 - Math.pow(x / eta, b) * b * (b + 1) / eta ** 2), 0) +
                  ds.reduce((acc, x) => acc - Math.pow(x / eta, b) * b * (b + 1) / eta ** 2, 0);
      const sum3 = df.reduce((acc, x) => acc + (-1 / eta + Math.pow(x / eta, b) * (b * Math.log(x / eta) + 1) / eta), 0) +
                  ds.reduce((acc, x) => acc + Math.pow(x / eta, b) * (b * Math.log(x / eta) + 1) / eta, 0);

      const fisher = math.matrix([[-sum1, -sum3], [-sum3, -sum2]]);
      const f_inv = math.inv(fisher);
      const z = jStat.normal.inv((1 + w.cl) / 2, 0, 1);

      const lower = [], upper = [];

      for (let x of rel) {
        const ln_ln = Math.log(-Math.log(1 - x));
        const var_y = f_inv.get([1,1]) / eta ** 2 +
                      (ln_ln ** 2) * f_inv.get([0,0]) / b ** 4 -
                      2 * ln_ln * f_inv.get([0,1]) / (b ** 2 * eta);

        const y = Math.log(eta) + ln_ln / b;
        const delta = z * Math.sqrt(var_y);
        lower.push(Math.exp(y - delta));
        upper.push(Math.exp(y + delta));
      }

      return { lower, upper };
    }

    function runAnalysis() {
      const dfInput = document.getElementById('df').value;
      const dsInput = document.getElementById('ds').value;

      const df = dfInput.split(',').map(Number).filter(v => !isNaN(v));
      const ds = dsInput.trim() === '' ? [] : dsInput.split(',').map(Number).filter(v => !isNaN(v));

      if (df.length < 2) {
        alert("请输入至少两个失效时间（df）！");
        return;
      }

      const w = new Weibull(df, ds);
      w.mle();

      const dataX = df.concat(ds);
      const minX = Math.min(...dataX) * 0.1;
      const maxX = Math.max(...dataX) * 10;

      const { x, y } = w.generateCDFCurve(minX, maxX);
      const mr = medianRanks(df, ds);
      const rel = Array.from({length: 98}, (_, i) => (i + 1) / 100);
      const bounds = fisherBounds(w, rel);

      Plotly.newPlot('plot', [
        { x, y, mode: 'lines', name: 'Weibull CDF' },
        { x: df, y: mr, mode: 'markers', name: 'Median Ranks' },
        { x: bounds.lower, y: rel, mode: 'lines', name: 'Lower Bound', line: { dash: 'dot' }},
        { x: bounds.upper, y: rel, mode: 'lines', name: 'Upper Bound', line: { dash: 'dot' }}
      ], {
        xaxis: { title: '时间', type: 'log' },
        yaxis: { title: '百分比', type: 'log' },
        title: `Weibull 分析图 - 形状(β): ${w.beta.toFixed(4)}，尺度(η): ${w.eta.toFixed(4)}`
      });
    }
  </script>
</body>
</html>
